// Reusable functions for processing OpenAPI specs and generated code

/**
 * Transform schema names to match OpenAPI Generator conventions
 */
ext.transformSchemaName = { String schemaName ->
    return schemaName.replaceAll('_', '')
}

/**
 * Analyze a oneOf variant and determine its type information
 */
ext.analyzeVariantType = { variant, interfaceName, idx ->
    def typeName = ""
    def javaType = ""
    
    if (variant?.'$ref') {
        // Reference to another schema
        def refName = variant.'$ref'.split('/').last()
        def transformedName = ext.transformSchemaName(refName)
        typeName = transformedName
        javaType = transformedName
    } else if (variant?.type == 'string') {
        typeName = "String"
        javaType = "String"
    } else if (variant?.type == 'integer') {
        typeName = "Integer"
        javaType = "Integer"
    } else if (variant?.type == 'number') {
        typeName = "Double"
        javaType = "Double"
    } else if (variant?.type == 'boolean') {
        typeName = "Boolean"
        javaType = "Boolean"
    } else if (variant?.type == 'array') {
        // Handle arrays recursively
        def itemsType = variant?.items
        if (itemsType?.type == 'string') {
            typeName = "ListString"
            javaType = "List<String>"
        } else if (itemsType?.type == 'integer') {
            typeName = "ListInteger"
            javaType = "List<Integer>"
        } else if (itemsType?.type == 'number') {
            typeName = "ListDouble"
            javaType = "List<Double>"
        } else if (itemsType?.type == 'boolean') {
            typeName = "ListBoolean"
            javaType = "List<Boolean>"
        } else if (itemsType?.type == 'array') {
            // Nested array
            if (itemsType?.items?.type == 'string') {
                typeName = "ListListString"
                javaType = "List<List<String>>"
            } else if (itemsType?.items?.type == 'integer') {
                typeName = "ListListInteger"
                javaType = "List<List<Integer>>"
            } else if (itemsType?.items?.type == 'number') {
                typeName = "ListListDouble"
                javaType = "List<List<Double>>"
            } else if (itemsType?.items?.type == 'boolean') {
                typeName = "ListListBoolean"
                javaType = "List<List<Boolean>>"
            } else {
                typeName = "ListList${itemsType?.items?.type?.capitalize() ?: 'Object'}"
                javaType = "List<List<Object>>"
            }
        } else if (itemsType?.'$ref') {
            def refName = itemsType.'$ref'.split('/').last()
            typeName = "List${refName}"
            javaType = "List<${refName}>"
        } else {
            typeName = "List${itemsType?.type?.capitalize() ?: 'Object'}"
            javaType = "List<Object>"
        }
    } else if (variant?.type == 'object') {
        typeName = "Object${idx}"
        javaType = "Object"
    } else {
        typeName = "Variant${idx}"
        javaType = "Object"
    }
    
    return [
        variantName: "${interfaceName}${typeName}",
        javaType: javaType,
        typeName: typeName
    ]
}

/**
 * Generate a record implementation for a oneOf variant
 */
ext.generateVariantRecord = { descriptor, interfaceName ->
    def imports = []
    if (descriptor.javaType.contains('List')) {
        imports << "import java.util.List;"
    }
    
    def importsSection = imports.isEmpty() ? "" : "\n${imports.join('\n')}"
    
    return """package org.cardanofoundation.signify.generated.keria.model;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;${importsSection}

/**
 * ${descriptor.typeName} variant for ${interfaceName}
 */
public record ${descriptor.variantName}(@JsonValue ${descriptor.javaType} value) implements ${interfaceName} {
    @JsonCreator
    public ${descriptor.variantName} {}
}
"""
}
